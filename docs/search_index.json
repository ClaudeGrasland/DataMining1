[["index.html", "DATA MINING Master Meci - Parcours Data - Options PISE et CCESE", " DATA MINING Master Meci - Parcours Data - Options PISE et CCESE Claude Grasland, Professeur de Géographie, Université de Paris (Diderot) 2021-02-23 "],["00-presentation.html", "Présentation À propos de ce document Prérequis Remerciements Licence", " Présentation À propos de ce document Ce document est la première version du cours de Data Mining dispensé aux étudiants de deuxième année de l’ option Data du master MECI Il est basé sur R version 4.0.2 (2020-06-22). Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse : https://ClaudeGrasland.github.io/DataMining1. Pour toute suggestion ou correction, il est possible de me contacter par mail Prérequis Le seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour installer R, il suffit de se rendre sur une des pages suivantes 1 : Installer R sous Windows Installer R sous Mac Pour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système : https://www.rstudio.com/products/rstudio/download/#download Remerciements Ce document a bénéficié de la relecture et des suggestions … des étudiants qui en ont été les cobayes des premières versions. Ce document est généré par l’excellente extension bookdown de Yihui Xie et il s’est servi du template proposé par Julien Barnier pour introduire des exercices interactifs dans son cours de tidyverse. Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Licence Creative Commons Sous Linux, utilisez votre gestionnaire de packages habituel.↩︎ "],["01-API-intro.html", "Chapitre 1 Collecter des données à l’aide d’une API 1.1 Qu’est-ce qu’une API ? 1.2 Comment utiliser une API dans R ? 1.3 API ou data packages ? 1.4 Exercices", " Chapitre 1 Collecter des données à l’aide d’une API library(knitr) library(httr) library(jsonlite) library(insee) library(dplyr) library(lubridate) 1.1 Qu’est-ce qu’une API ? 1.1.1 Définitions On peut partir de la définition suivante En informatique, API est l’acronyme d’Application Programming Interface, que l’on traduit en français par interface de programmation applicative ou interface de programmation d’application. L’API peut être résumée à une solution informatique qui permet à des applications de communiquer entre elles et de s’échanger mutuellement des services ou des données. Il s’agit en réalité d’un ensemble de fonctions qui facilitent, via un langage de programmation, l’accès aux services d’une application. (Source : Journal du Net) 1.1.2 Domaine d’application Une API peut remplir des fonctions très diverses : Dans le domaine d’internet, l’API permet aux développeurs de pouvoir utiliser un programme sans avoir à se soucier du fonctionnement complexe d’une application. Les API peuvent par exemple être utilisées pour déclencher des campagnes publicitaires d’e-mailing de façon automatique sans avoir à passer par la compréhension d’une telle application (c’est le cas avec l’API AdWords de Google, par exemple). On les retrouve aujourd’hui dans de nombreux logiciels, en particulier dans les systèmes d’exploitation, les serveurs d’applications, dans le monde du graphisme (OpenGL), dans les applications SaaS (Office 365, G Suite, Salesforce…), les bases de données, l’open data, etc.(Source : Journal du Net) 1.1.3 Système client-serveur D’une manière générale, les API supposent un échange d’informations entre un client et un serveur. Ces échanges d’informations suivent un protocole c’est-à-dire un ensemble de règles. Il existe deux grands protocoles de communication sur lesquels s’adossent les API : Simple Object Access Protocol (SOAP) et Representational State Transfer (REST). Le second s’est désormais largement imposé face au premier car il est plus flexible. Il a donné naissance aux API dites REST ou RESTful (Source : Journal du Net) 1.2 Comment utiliser une API dans R ? Le métier de data analyst implique presque nécessairement l’emploi d’API. Les langages de programmation R ou Python ont donc l’un comme l’autre mis au point des packages pour faciliter l’envoi de requêtes sur des serveurs dotés d’API. A titre d’introduction, nous allons reprendre (et traduire en français) quelques extraits d’un billet proposé par un étudiant en doctorat de biostatistiques à l’université de Californie San Diego. Pascual C., 2020, Getting Started with APIs in R 1.2.1 Pourquoi utiliser des API ? «API» est un terme général désignant le lieu où un programme informatique interagit avec un autre ou avec lui-même. Dans ce didacticiel, nous travaillerons spécifiquement avec des API Web, où deux ordinateurs différents - un client et un serveur - interagiront l’un avec l’autre pour demander et fournir des données, respectivement. Les API offrent aux scientifiques des données un moyen raffiné de demander des données propres et organisées à partir d’un site Web. Lorsqu’un site Web comme Facebook met en place une API, il met essentiellement en place un ordinateur qui attend les demandes de données. Une fois que cet ordinateur reçoit une demande de données, il effectuera son propre traitement des données et les enverra à l’ordinateur qui l’a demandé. De notre point de vue en tant que demandeur, nous devrons écrire du code dans R qui crée la demande et indique à l’ordinateur exécutant l’API ce dont nous avons besoin. Cet ordinateur lira ensuite notre code, traitera la requête et renverra des données bien formatées qui peuvent être facilement analysées par les bibliothèques R existantes. Pourquoi est-ce précieux? Comparez l’approche API au scraping Web pur. Lorsqu’un programmeur gratte une page Web, il reçoit les données dans un morceau de HTML désordonné. Bien qu’il existe certainement des bibliothèques qui facilitent l’analyse du texte HTML, ce sont toutes des étapes de nettoyage qui doivent être prises avant même de mettre la main sur les données que nous voulons! Souvent, nous pouvons immédiatement utiliser les données que nous obtenons d’une API, ce qui nous fait gagner du temps et de la frustration. Source : Traduction française d’un billet de Pascual C., 2020 1.2.2 Installer les packages jsonlite et httr Pour travailler avec des API dans R, nous devons intégrer certaines bibliothèques (library). Ces bibliothèques prennent toutes les complexités d’une requête d’API et les enveloppent dans des fonctions que nous pouvons utiliser dans des lignes de code uniques. Les bibliothèques R que nous utiliserons sont httr et jsonlite. Elles remplissent des rôles différents dans notre introduction des API, mais les deux sont essentiels.Si vous ne disposez pas de ces bibliothèques dans votre console R ou RStudio, vous devez d’abord les télécharger. library(httr) library(jsonlite) 1.2.3 Structure d’une requête Une requête adressé à une API va suivre le schéma suivant : knitr::include_graphics(&quot;img/API_GET.png&quot;,) Il existe plusieurs types de requêtes que l’on peut adresser à un serveur API. Pour nos besoins, nous allons simplement demander des données, ce qui correspond à une demande GET. Les autres types de requêtes sont POST et PUT, mais nous n’avons pas à nous en préoccuper dans l’immédiat Afin de créer une requête GET, nous devons utiliser la fonction GET() de la bibliothèque httr. La fonction GET() nécessite une URL, qui spécifie l’adresse du serveur auquel la demande doit être envoyée. A titre d’exemple, C. Pascual propose de travailler avec l’API Open Notify, qui donne accès à des données sur divers projets de la NASA. À l’aide de l’API Open Notify, nous pouvons notamment en savoir plus sur l’emplacement de la Station spatiale internationale et sur le nombre de personnes actuellement dans l’espace. Notre programme télécharge les données disponibles à l’adresse du serveur et les stocke dans un objet auquel on peut donner le nom que l’on souhaite, par exemple toto toto &lt;- GET(&quot;http://api.open-notify.org/astros.json&quot;) toto Response [http://api.open-notify.org/astros.json] Date: 2021-02-23 20:11 Status: 200 Content-Type: application/json Size: 356 B Lorsqu’on affiche la réponse, on obtient ici quatre informations : Date : le moment exact du téléchargement, très utile pour suivre les mises à jour Status : le code informatique de résultat de la requête. La valeur 200 indique un succès alors que les autres valeurs signaleront un problème. Content-Type : le type d’information recueillie. Ici, une application au format json Size : la taille du fichier résultant du transfert. On pourrait également en savoir plus en tapant la commande str() qui nous indique que le résultat est une liste comportant 10 branches et de nombreuses sous-branches : str(toto) List of 10 $ url : chr &quot;http://api.open-notify.org/astros.json&quot; $ status_code: int 200 $ headers :List of 6 ..$ server : chr &quot;nginx/1.10.3&quot; ..$ date : chr &quot;Tue, 23 Feb 2021 20:11:55 GMT&quot; ..$ content-type : chr &quot;application/json&quot; ..$ content-length : chr &quot;356&quot; ..$ connection : chr &quot;keep-alive&quot; ..$ access-control-allow-origin: chr &quot;*&quot; ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;insensitive&quot; &quot;list&quot; $ all_headers:List of 1 ..$ :List of 3 .. ..$ status : int 200 .. ..$ version: chr &quot;HTTP/1.1&quot; .. ..$ headers:List of 6 .. .. ..$ server : chr &quot;nginx/1.10.3&quot; .. .. ..$ date : chr &quot;Tue, 23 Feb 2021 20:11:55 GMT&quot; .. .. ..$ content-type : chr &quot;application/json&quot; .. .. ..$ content-length : chr &quot;356&quot; .. .. ..$ connection : chr &quot;keep-alive&quot; .. .. ..$ access-control-allow-origin: chr &quot;*&quot; .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;insensitive&quot; &quot;list&quot; $ cookies :&#39;data.frame&#39;: 0 obs. of 7 variables: ..$ domain : logi(0) ..$ flag : logi(0) ..$ path : logi(0) ..$ secure : logi(0) ..$ expiration: &#39;POSIXct&#39; num(0) ..$ name : logi(0) ..$ value : logi(0) $ content : raw [1:356] 7b 22 6d 65 ... $ date : POSIXct[1:1], format: &quot;2021-02-23 20:11:55&quot; $ times : Named num [1:6] 0 0.349 0.512 0.512 0.676 ... ..- attr(*, &quot;names&quot;)= chr [1:6] &quot;redirect&quot; &quot;namelookup&quot; &quot;connect&quot; &quot;pretransfer&quot; ... $ request :List of 7 ..$ method : chr &quot;GET&quot; ..$ url : chr &quot;http://api.open-notify.org/astros.json&quot; ..$ headers : Named chr &quot;application/json, text/xml, application/xml, */*&quot; .. ..- attr(*, &quot;names&quot;)= chr &quot;Accept&quot; ..$ fields : NULL ..$ options :List of 2 .. ..$ useragent: chr &quot;libcurl/7.64.1 r-curl/4.3 httr/1.4.2&quot; .. ..$ httpget : logi TRUE ..$ auth_token: NULL ..$ output : list() .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;write_memory&quot; &quot;write_function&quot; ..- attr(*, &quot;class&quot;)= chr &quot;request&quot; $ handle :Class &#39;curl_handle&#39; &lt;externalptr&gt; - attr(*, &quot;class&quot;)= chr &quot;response&quot; La branche qui nous intéresse le plus est content puisque c’est celle qui contient les données. 1.2.4 Extraction des données Les données contenues dans la réponse ont été stockées au format JSON (JavaScript Object Notation) qui est devenu un standard pour les échanges de données. Sans entrer dans le détail de ce langage, on retiendra qu’il va falloir convertir les données JSON dans un format de tableau lisible par R ce qui se fait ici en deux étapes. Tout d’abord extraire le champ content et le convertir en mode caractère : # conversion du contenu de toto en mode character toto2&lt;-rawToChar(toto$content) toto2 [1] &quot;{\\&quot;message\\&quot;: \\&quot;success\\&quot;, \\&quot;number\\&quot;: 7, \\&quot;people\\&quot;: [{\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Sergey Ryzhikov\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Kate Rubins\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Sergey Kud-Sverchkov\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Mike Hopkins\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Victor Glover\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Shannon Walker\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Soichi Noguchi\\&quot;}]}&quot; str(toto2) chr &quot;{\\&quot;message\\&quot;: \\&quot;success\\&quot;, \\&quot;number\\&quot;: 7, \\&quot;people\\&quot;: [{\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Sergey Ryzhikov\\&quot;}, {\\&quot;&quot;| __truncated__ Puis convertir ces données de type JSON en données utilisables par R à l’aide de la fonction fromJson() du package jsonlite() toto3 &lt;- fromJSON(toto2) str(toto3) List of 3 $ message: chr &quot;success&quot; $ number : int 7 $ people :&#39;data.frame&#39;: 7 obs. of 2 variables: ..$ craft: chr [1:7] &quot;ISS&quot; &quot;ISS&quot; &quot;ISS&quot; &quot;ISS&quot; ... ..$ name : chr [1:7] &quot;Sergey Ryzhikov&quot; &quot;Kate Rubins&quot; &quot;Sergey Kud-Sverchkov&quot; &quot;Mike Hopkins&quot; ... On obtient finalement une liste de trois éléments dont le dernier est un data.frame décrivant les astronautes présents dans la station spatiale internationale au moment de l’execution du programme. toto4&lt;-toto3$people str(toto4) &#39;data.frame&#39;: 7 obs. of 2 variables: $ craft: chr &quot;ISS&quot; &quot;ISS&quot; &quot;ISS&quot; &quot;ISS&quot; ... $ name : chr &quot;Sergey Ryzhikov&quot; &quot;Kate Rubins&quot; &quot;Sergey Kud-Sverchkov&quot; &quot;Mike Hopkins&quot; ... kable(toto4,caption = &quot;Passagers de l&#39;ISS en temps réel&quot;) Table 1.1: Passagers de l’ISS en temps réel craft name ISS Sergey Ryzhikov ISS Kate Rubins ISS Sergey Kud-Sverchkov ISS Mike Hopkins ISS Victor Glover ISS Shannon Walker ISS Soichi Noguchi 1.2.5 API et mise à jour en temps réel Sur le site web du billet proposé par C. Pascual en février 2020, on trouve une autre liste ne comportant que 6 passagers et avec des noms totalement différents : Table 1.2: Passagers de l’ISS en février 2020 craft name ISS Christina Koch ISS Alexander Skvortsov ISS Luca Parmitano ISS Andrew Morgan ISS Oleg Skripochka ISS Jessica Meir En effet, l’API renvoie les résultats au moment de l’execution de la fonction GET() ce qui correspond à février 2020 pour le billet de blog. Or, les astronautes sont remplacés au plus tous les six mois ce qui explique que tous les noms soient différents un an après. NB : Cet exemple permet de mettre en évidence une fonction centrale des API qui est la mise à jour en temps réel des données ! 1.2.6 API et requête paramétrique L’exemple précédent consistait à télécharger la totalité d’un tableau et ne demandait donc pas de paramètres particuliers. Mais il peut aussi arriver (par exemple si une base de données est très volumineuse) que l’on précise à l’aide de paramètres ce que l’on veut précisément télécharger. A titre d’exemple, C. Pascual propose d’utiliser une autre API de la NASA intitulée ISS Pass Time qui permet de savoir à quel moment la station ISS passera au dessus d’un certain point du globe. L’exemple choisi par C.Pascual est la recherche des trois prochaines dates de passage de l’ISS au dessus de New York dont les coordonnées de latitude et de longitude sont 40.7 et -74.0 : titi &lt;- GET(&quot;http://api.open-notify.org/iss-pass.json&quot;, query = list(lat = 40.7, lon = -74, n=3)) titi2 &lt;- fromJSON(rawToChar(titi$content)) titi3 &lt;- titi2$response titi3 # A tibble: 3 x 2 duration risetime &lt;int&gt; &lt;int&gt; 1 426 1614151968 2 648 1614157625 3 617 1614163462 Le résultat paraît à première vue assez déconcertant. Mais la lecture de la documentation de l’API indique que les deux variables du tableau correspondent respectivement : duration : nombre de secondes pendant lesquelles la station sera à la verticale du point avec un angle de + ou - 10 degrés. risetime : moment de passage exprimé en Unix Time c’est-à-dire en nombre de secondes écoulées depuis le 1er Janvier 1970 UTC. Si l’on veut se ramener à une date précise, il faut donc convertir ce temps à l’aide d’une fonction R. Le plus simple est pour cela d’utiliser la fonction as_datetime() du package lubridate. library(lubridate) titi3$risetime&lt;-as_datetime(titi3$risetime) kable(titi3) duration risetime 426 2021-02-24 07:32:48 648 2021-02-24 09:07:05 617 2021-02-24 10:44:22 1.3 API ou data packages ? L’utilisation d’API à l’aide des fonctions de base httpr et jsonlite constitue à moyen terme une étape indispensable de la formation d’un data analyste. Mais heureusement elle n’est pas toujours indispensable pour le débutant car plusieurs packages R (ou Python) ont été développées par des programmeurs pour faciliter l’usage des API. Ces packages executent en pratique les commandes de l’API, mais sans que l’utilisateur ait besoin d’avoir aucune connaissance sur la syntaxe de la fonction GET() qui a collecté les données ni des transformations effectuées sur les résultats pour transformer les données JSON en data.frame ou tibble. La connaissance de ces packages spécialisées offre donc une grosse économie de temps … s’ils ont été bien conçus. On va prendre comme exemple le package insee mis au point récemment pour faciliter l’accès aux données de cette organisation. La documentation du package est accessible par le lien ci-dessous https://www.data.gouv.fr/fr/reuses/insee-package-r/ Cette page renvoie vers une “vignette” c’est-à-dire une suite de programmes exemples. https://inseefr.github.io/R-Insee-Data/ 1.3.1 Installation et chargement du package On commence par installer le package insee ce qui peut prendre quelques minutes mais sera fait une seule fois (sauf mise à jour). # install.packages(&quot;insee&quot;) On peut ensuite lancer le package pour l’utiliser avec library() et on ajoute le package tidyverse que l’INSEE semble privilégier pour l’exploitation des données : library(insee) library(tidyverse,warn.conflicts = F) 1.3.2 Chargement de la liste des tableaux On commence par télécharger le catalogue des tableaux de données disponibles,à l’aide de la commande get_dataset_list() catalogue = get_dataset_list() kable(head(catalogue)) id Name.fr Name.en url n_series BALANCE-PAIEMENTS Balance des paiements Balance of payments https://www.insee.fr/fr/statistiques/series/103212755 197 CHOMAGE-TRIM-NATIONAL Chômage, taux de chômage par sexe et âge (sens BIT) Unemployment, unemployment rate and halo by sex and age (ILO) https://www.insee.fr/fr/statistiques/series/103167923 166 CLIMAT-AFFAIRES Indicateurs synthétiques du climat des affaires Business climate composite indicators https://www.insee.fr/fr/statistiques/series/103047029 3 CNA-2010-CONSO-MEN Consommation des ménages - Résultats par produit, fonction et durabilité Households’ consumption - Results by product, function and durability https://www.insee.fr/fr/statistiques/series/102331845 2247 CNA-2010-CONSO-SI Dépenses de consommation finale par secteur institutionnel - Résultats par opération et produit Final consumption expenditure by institutional sectors - Results by transaction and product https://www.insee.fr/fr/statistiques/series/102809534 1391 CNA-2010-CPEB Comptes de production et d’exploitation par branche Production and operating accounts by branch https://www.insee.fr/fr/statistiques/series/102852781 2739 Chaque tableau comporte un très grand nombre de séries chronologiques parmi lesquelles il faut opérer un choix afin d’extraire exactement ce que l’on veut. 1.3.3 Examen des séries présentes dans un tableau Une fois que l’on a choisi un tableau, on peut examiner plus en détail les différentes séries qui y sont présentes à l’aide de la commande get_idbank_list(). On va par exemple examiner le contenu de la base de données “DECES-MORTALITE” : var&lt;-get_idbank_list(&quot;DECES-MORTALITE&quot;) str(var) FALSE tibble [1,905 × 39] (S3: tbl_df/tbl/data.frame) FALSE $ nomflow : chr [1:1905] &quot;DECES-MORTALITE&quot; &quot;DECES-MORTALITE&quot; &quot;DECES-MORTALITE&quot; &quot;DECES-MORTALITE&quot; ... FALSE $ idbank : chr [1:1905] &quot;000436398&quot; &quot;001641606&quot; &quot;000869058&quot; &quot;001780755&quot; ... FALSE $ cleFlow : chr [1:1905] &quot;M.TAUX_MORTALITE.TAUX.TXMORINF.FM.0.SO.SO.BRUT&quot; &quot;M.TAUX_MORTALITE.TAUX.TXMORINF.FR-D976.0.SO.SO.BRUT&quot; &quot;A.DECES_DOMICILIES.VALEUR_ABSOLUE.DECES-DOM.AU.SO.SO.NOMBRE.BRUT&quot; &quot;A.DECES_DOMICILIES.VALEUR_ABSOLUE.DECES-DOM.F_H_IDF.SO.SO.NOMBRE.BRUT&quot; ... FALSE $ FREQ : chr [1:1905] &quot;M&quot; &quot;M&quot; &quot;A&quot; &quot;A&quot; ... FALSE $ INDICATEUR : chr [1:1905] &quot;TAUX_MORTALITE&quot; &quot;TAUX_MORTALITE&quot; &quot;DECES_DOMICILIES&quot; &quot;DECES_DOMICILIES&quot; ... FALSE $ NATURE : chr [1:1905] &quot;TAUX&quot; &quot;TAUX&quot; &quot;VALEUR_ABSOLUE&quot; &quot;VALEUR_ABSOLUE&quot; ... FALSE $ DEMOGRAPHIE : chr [1:1905] &quot;TXMORINF&quot; &quot;TXMORINF&quot; &quot;DECES-DOM&quot; &quot;DECES-DOM&quot; ... FALSE $ REF_AREA : chr [1:1905] &quot;FM&quot; &quot;FR-D976&quot; &quot;AU&quot; &quot;F_H_IDF&quot; ... FALSE $ SEXE : chr [1:1905] &quot;0&quot; &quot;0&quot; &quot;SO&quot; &quot;SO&quot; ... FALSE $ AGE : chr [1:1905] &quot;SO&quot; &quot;SO&quot; &quot;SO&quot; &quot;SO&quot; ... FALSE $ UNIT_MEASURE : chr [1:1905] &quot;SO&quot; &quot;SO&quot; &quot;NOMBRE&quot; &quot;NOMBRE&quot; ... FALSE $ CORRECTION : chr [1:1905] &quot;BRUT&quot; &quot;BRUT&quot; &quot;BRUT&quot; &quot;BRUT&quot; ... FALSE $ FREQ_label_fr : chr [1:1905] &quot;Mensuelle&quot; &quot;Mensuelle&quot; &quot;Annuelle&quot; &quot;Annuelle&quot; ... FALSE $ FREQ_label_en : chr [1:1905] &quot;Monthly&quot; &quot;Monthly&quot; &quot;Annual&quot; &quot;Annual&quot; ... FALSE $ INDICATEUR_label_fr : chr [1:1905] &quot;Taux de mortalité&quot; &quot;Taux de mortalité&quot; &quot;Décès domiciliés&quot; &quot;Décès domiciliés&quot; ... FALSE $ INDICATEUR_label_en : chr [1:1905] &quot;Mortality rate&quot; &quot;Mortality rate&quot; &quot;Deaths domiciled&quot; &quot;Deaths domiciled&quot; ... FALSE $ NATURE_label_fr : chr [1:1905] &quot;Taux&quot; &quot;Taux&quot; &quot;Valeur absolue&quot; &quot;Valeur absolue&quot; ... FALSE $ NATURE_label_en : chr [1:1905] &quot;Rate&quot; &quot;Rate&quot; &quot;Absolute value&quot; &quot;Absolute value&quot; ... FALSE $ DEMOGRAPHIE_label_fr : chr [1:1905] &quot;Taux de mortalité infantile&quot; &quot;Taux de mortalité infantile&quot; &quot;Décès de tous âges, domiciliés&quot; &quot;Décès de tous âges, domiciliés&quot; ... FALSE $ DEMOGRAPHIE_label_en : chr [1:1905] &quot;Infant mortality rate&quot; &quot;Infant mortality rate&quot; &quot;Deaths of all ages, with home address&quot; &quot;Deaths of all ages, with home address&quot; ... FALSE $ REF_AREA_label_fr : chr [1:1905] &quot;France métropolitaine&quot; &quot;France hors Mayotte&quot; &quot;Territoires d&#39;outre-mer (TOM) + Étranger&quot; &quot;France métropolitaine hors Île-de-France&quot; ... FALSE $ REF_AREA_label_en : chr [1:1905] &quot;Metropolitan France&quot; &quot;France excluding Mayotte&quot; &quot;French overseas territories (TOM) + Abroad&quot; &quot;Metropolitan France excluding Île-de-France&quot; ... FALSE $ SEXE_label_fr : chr [1:1905] &quot;Ensemble&quot; &quot;Ensemble&quot; &quot;Sans objet&quot; &quot;Sans objet&quot; ... FALSE $ SEXE_label_en : chr [1:1905] &quot;All&quot; &quot;All&quot; &quot;Not applicable&quot; &quot;Not applicable&quot; ... FALSE $ AGE_label_fr : chr [1:1905] &quot;Sans objet&quot; &quot;Sans objet&quot; &quot;Sans objet&quot; &quot;Sans objet&quot; ... FALSE $ AGE_label_en : chr [1:1905] &quot;Not applicable&quot; &quot;Not applicable&quot; &quot;Not applicable&quot; &quot;Not applicable&quot; ... FALSE $ UNIT_MEASURE_label_fr: chr [1:1905] &quot;sans objet&quot; &quot;sans objet&quot; &quot;nombre&quot; &quot;nombre&quot; ... FALSE $ UNIT_MEASURE_label_en: chr [1:1905] &quot;not applicable&quot; &quot;not applicable&quot; &quot;number&quot; &quot;number&quot; ... FALSE $ CORRECTION_label_fr : chr [1:1905] &quot;Non corrigé&quot; &quot;Non corrigé&quot; &quot;Non corrigé&quot; &quot;Non corrigé&quot; ... FALSE $ CORRECTION_label_en : chr [1:1905] &quot;Uncorrected&quot; &quot;Uncorrected&quot; &quot;Uncorrected&quot; &quot;Uncorrected&quot; ... FALSE $ dim1 : chr [1:1905] &quot;M&quot; &quot;M&quot; &quot;A&quot; &quot;A&quot; ... FALSE $ dim2 : chr [1:1905] &quot;TAUX_MORTALITE&quot; &quot;TAUX_MORTALITE&quot; &quot;DECES_DOMICILIES&quot; &quot;DECES_DOMICILIES&quot; ... FALSE $ dim3 : chr [1:1905] &quot;TAUX&quot; &quot;TAUX&quot; &quot;VALEUR_ABSOLUE&quot; &quot;VALEUR_ABSOLUE&quot; ... FALSE $ dim4 : chr [1:1905] &quot;TXMORINF&quot; &quot;TXMORINF&quot; &quot;DECES-DOM&quot; &quot;DECES-DOM&quot; ... FALSE $ dim5 : chr [1:1905] &quot;FM&quot; &quot;FR-D976&quot; &quot;AU&quot; &quot;F_H_IDF&quot; ... FALSE $ dim6 : chr [1:1905] &quot;0&quot; &quot;0&quot; &quot;SO&quot; &quot;SO&quot; ... FALSE $ dim7 : chr [1:1905] &quot;SO&quot; &quot;SO&quot; &quot;SO&quot; &quot;SO&quot; ... FALSE $ dim8 : chr [1:1905] &quot;SO&quot; &quot;SO&quot; &quot;NOMBRE&quot; &quot;NOMBRE&quot; ... FALSE $ dim9 : chr [1:1905] &quot;BRUT&quot; &quot;BRUT&quot; &quot;BRUT&quot; &quot;BRUT&quot; ... Le résultat est un tibble comportant 1905 lignes et 39 colonnes. Il correspond en pratique aux 1905 séries chronologiques que l’on peut extraire de la base de données. Chaque série dispose d’un code unique contenu dans la variable idbank. 1.3.4 Extraction d’une série à l’aide de son identifiant Une première solution pour extraire une série consiste à parcourir le tableau des variables jusqu’à repérer la ligne qui nous intéresse puis à noter son idbank et à extraire la série correspondante à l’aide de la fonction get_insee_idbank(). Par exemple, la première ligne du tableau des variables dont le code est “000436398” va renvoyer un tableau du taux brut de mortalité infantile en France métropolitaine de Janvier 1975 à Décembre 2014. On peut en faire rapidement un graphique avec la fonction plot() de R-Base don&lt;-get_insee_idbank(&quot;000436398&quot;) FALSE | | | 0% | |======================================================================| 100% don&lt;-don[order(don$DATE),1:3] plot(don$DATE,don$OBS_VALUE, type =&quot;l&quot;, col=&quot;red&quot;, ylab = &quot;Décès 0-1 ans pour 1000 naissances&quot;, xlab = &quot;Données mensuelles&quot;, main = &quot;Evolution de la mortalité infantile en France (1975-2014)&quot;, sub = &quot;Source : Insee&quot;) On remarque que la courbe a des oscillations saisonnières beaucoup moins fortes après 1995 ce qui est sans doute lié à un changement dans le mode de collecte des données plutôt qu’à la réalité. On note aussi que les données s’arrêtent en 2014 ce qui est bizarre puisque l’API devrait nous donner les chiffres les plus récents. en fait les données plus récentes sont disponibles mais elles font partie d’une autre série de données. 1.3.5 Extraction d’un ensemble de séries d’un même tableau Supposons que l’on veuille extraire trois courbes décrivant l’espérance de vie des hommes en France métropolitaine, à 20, 40 et 60 ans. Nous lançons alors une requête pour ne retenir dans le tableau des variables que les lignes qui nous intéressent. sel = get_idbank_list(&quot;DECES-MORTALITE&quot;) %&gt;% filter(SEXE == &quot;1&quot;) %&gt;% filter(FREQ == &quot;A&quot;) %&gt;% #données annuelles filter(REF_AREA == &quot;FM&quot;) %&gt;% #France métropolitaine filter(DEMOGRAPHIE %in% c(&quot;ESPV-20&quot;,&quot;ESPV-40&quot;,&quot;ESPV-60&quot;)) # Espérance de vie kable(head(sel)) nomflow idbank cleFlow FREQ INDICATEUR NATURE DEMOGRAPHIE REF_AREA SEXE AGE UNIT_MEASURE CORRECTION FREQ_label_fr FREQ_label_en INDICATEUR_label_fr INDICATEUR_label_en NATURE_label_fr NATURE_label_en DEMOGRAPHIE_label_fr DEMOGRAPHIE_label_en REF_AREA_label_fr REF_AREA_label_en SEXE_label_fr SEXE_label_en AGE_label_fr AGE_label_en UNIT_MEASURE_label_fr UNIT_MEASURE_label_en CORRECTION_label_fr CORRECTION_label_en dim1 dim2 dim3 dim4 dim5 dim6 dim7 dim8 dim9 DECES-MORTALITE 001686948 A.ESPERANCE_VIE.VALEUR_ABSOLUE.ESPV-20.FM.1.SO.ANNEES.BRUT A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-20 FM 1 SO ANNEES BRUT Annuelle Annual Espérance de vie Life expectancy Valeur absolue Absolute value Espérance de vie à 20 ans Life expectancy at 20 years France métropolitaine Metropolitan France Hommes Men Sans objet Not applicable nombre d’années number of years Non corrigé Uncorrected A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-20 FM 1 SO ANNEES BRUT DECES-MORTALITE 001686949 A.ESPERANCE_VIE.VALEUR_ABSOLUE.ESPV-40.FM.1.SO.ANNEES.BRUT A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-40 FM 1 SO ANNEES BRUT Annuelle Annual Espérance de vie Life expectancy Valeur absolue Absolute value Espérance de vie à 40 ans Life expectancy at 40 years France métropolitaine Metropolitan France Hommes Men Sans objet Not applicable nombre d’années number of years Non corrigé Uncorrected A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-40 FM 1 SO ANNEES BRUT DECES-MORTALITE 001686950 A.ESPERANCE_VIE.VALEUR_ABSOLUE.ESPV-60.FM.1.SO.ANNEES.BRUT A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-60 FM 1 SO ANNEES BRUT Annuelle Annual Espérance de vie Life expectancy Valeur absolue Absolute value Espérance de vie à 60 ans Life expectancy at 60 years France métropolitaine Metropolitan France Hommes Men Sans objet Not applicable nombre d’années number of years Non corrigé Uncorrected A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-60 FM 1 SO ANNEES BRUT DECES-MORTALITE 010536470 A.ESPERANCE_VIE.VALEUR_ABSOLUE.ESPV-20.FM.1.SO.ANNEES.BRUT A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-20 FM 1 SO ANNEES BRUT Annuelle Annual Espérance de vie Life expectancy Valeur absolue Absolute value Espérance de vie à 20 ans Life expectancy at 20 years France métropolitaine Metropolitan France Hommes Men Sans objet Not applicable nombre d’années number of years Non corrigé Uncorrected A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-20 FM 1 SO ANNEES BRUT DECES-MORTALITE 010536474 A.ESPERANCE_VIE.VALEUR_ABSOLUE.ESPV-40.FM.1.SO.ANNEES.BRUT A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-40 FM 1 SO ANNEES BRUT Annuelle Annual Espérance de vie Life expectancy Valeur absolue Absolute value Espérance de vie à 40 ans Life expectancy at 40 years France métropolitaine Metropolitan France Hommes Men Sans objet Not applicable nombre d’années number of years Non corrigé Uncorrected A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-40 FM 1 SO ANNEES BRUT DECES-MORTALITE 010536478 A.ESPERANCE_VIE.VALEUR_ABSOLUE.ESPV-60.FM.1.SO.ANNEES.BRUT A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-60 FM 1 SO ANNEES BRUT Annuelle Annual Espérance de vie Life expectancy Valeur absolue Absolute value Espérance de vie à 60 ans Life expectancy at 60 years France métropolitaine Metropolitan France Hommes Men Sans objet Not applicable nombre d’années number of years Non corrigé Uncorrected A ESPERANCE_VIE VALEUR_ABSOLUE ESPV-60 FM 1 SO ANNEES BRUT On découvre que le programme renvoie 6 lignes au lieu de 3. Pourquoi ? Parce que l’INSEE stocke différemment des séries anciennes et des séries récentes. Il faut donc effectuer une requête sur les 4 codes à la fois pour avoir la série la plus longue. 1.3.6 Recupération et nettoyage des données On récupère les données puis on procède à un petit nettoyage du tableau pour ne conserver que les colonnes utiles. don = get_insee_idbank(sel$idbank) FALSE | | | 0% | |===== | 7% | |========== | 14% | |=============== | 22% | |================================= | 48% | |==================================================== | 74% | |======================================================================| 100% don2&lt;-don %&gt;% select(ANNEE = DATE, ESPVIE= OBS_VALUE, AGE = TITLE_FR) %&gt;% mutate(AGE = as.factor(AGE)) %&gt;% arrange(AGE, ANNEE) levels(don2$AGE) &lt;- c(&quot;20 ans&quot;, &quot;40 ans&quot;,&quot;60 ans&quot;) kable(head(don2)) ANNEE ESPVIE AGE 1946-01-01 48.0 20 ans 1947-01-01 48.4 20 ans 1948-01-01 48.5 20 ans 1949-01-01 48.2 20 ans 1950-01-01 48.7 20 ans 1951-01-01 48.2 20 ans 1.3.7 Construction d’un graphique On peut maintenant construire notre graphique à l’aide par exemple de ggplot2 : p&lt;-ggplot(don2) + aes(x=ANNEE,y=ESPVIE, color = AGE) + geom_line() + ggtitle(label= &quot;Espérance de vie en France Métropolitaine&quot;, subtitle = &quot;Source : INSEE&quot;)+ scale_x_date(&quot;Données annuelles&quot;) + scale_y_continuous(&quot;Années de vie restantes&quot;,limits = c(0,NA)) p 1.3.8 Discussion Comme on peut le voir, l’utilisation d’un package simplifie l’usage des API mais ne dispense pas d’un apprentissage souvent long pour comprendre toutes les finesses du package (et parfois ses bugs …). Dans le cas du package INSEE, l’utilisation s’avère assez lourde mais permet d’accéder à un nombre considérable de données ! 1.4 Exercices 1.4.1 Exercice 1 : utilisation de httr et jsonlite Déterminer la durée et la date des 10 prochains dates de passage de l’ISS au dessus de Paris (Latitude = 48.86, Longitude = 2.35) Table 1.3: Prochains passages de l’ISS au dessus de Paris duration risetime 356 2021-02-24 02:57:06 621 2021-02-24 04:30:47 655 2021-02-24 06:07:06 651 2021-02-24 07:44:10 655 2021-02-24 09:21:07 591 2021-02-24 10:58:05 70 2021-02-25 02:12:25 591 2021-02-25 03:43:45 654 2021-02-25 05:19:40 651 2021-02-25 06:56:40 titi &lt;- GET(&quot;http://api.open-notify.org/iss-pass.json&quot;, query = list(lat = 40.7, lon = -74, n=3)) titi2 &lt;- fromJSON(rawToChar(titi$content)) titi3 &lt;- titi2$response titi3$time&lt;-as_datetime(titi3$risetime) kable(titi3, caption = &quot;Prochains passages de l&#39;ISS au dessus de Paris&quot;) 1.4.2 Exercice 2 : utilisation du package ‘insee’ Construire à l’aide du package INSEE un graphique de l’évolution mensuelle de l’espérance de vie des femmes à la naissance en France Métropolitaine de 1945 à 2020. FALSE | | | 0% | |=============== | 21% | |======================================================================| 100% #library(insee) #library(tidyverse) sel = get_idbank_list(&quot;DECES-MORTALITE&quot;) %&gt;% filter(SEXE == &quot;2&quot;) %&gt;% filter(FREQ == &quot;A&quot;) %&gt;% #données mensuelles filter(REF_AREA == &quot;FM&quot;) %&gt;% #France métropolitaine filter(DEMOGRAPHIE %in% c(&quot;ESPV&quot;)) # Espérance de vie don = get_insee_idbank(sel$idbank) %&gt;% select(ANNEE = DATE, ESPVIE= OBS_VALUE) %&gt;% arrange(ANNEE) p = ggplot(don) + aes(x=ANNEE,y=ESPVIE) + geom_line(col=&quot;red&quot;) + geom_smooth(method= &quot;lm&quot;,col=&quot;blue&quot;)+ ggtitle(label= &quot;Espérance de vie à la naissance des femmes en France Métropolitaine&quot;, subtitle = &quot;Source : INSEE&quot;)+ scale_x_date(&quot;Année&quot;, limits =as.Date(c(&quot;1940-01-01&quot;,&quot;2020-01-01&quot;))) + scale_y_continuous(&quot;Durée de vie moyenne&quot;) p 1.4.3 Exercice 3 : Osrm On se propose de calculer la distance routière Paris Rouen en temps et en kilomètre à l’aide de l’API osrm. Paris (48.863186 ; 2.339754) Rouen (49.443232.; 1.099971) Vous pouvez effectuer le calcul : soit avec l’API osrm http://project-osrm.org/docs/v5.15.2/api/#general-options soit avec le package R osrm de Thimotee Giraud qui émule l’API https://rgeomatic.hypotheses.org/1798 1.4.4 Exercice 4 : Exploration de nouvelles API Vous devez identifier une API intéressante, accessible soit par un package R, soit par une combinaison de comandes GET() puis montrer son utilisation à l’aide d’un exemple de création d’un tableau puis d’un graphique. Vous présenterez le résultat sous la forme d’un document markdown d’une à deux pages maximum. "],["02-API-worldstat.html", "Chapitre 2 L’API Wbstats (Banque Mondiale) 2.1 Objectifs 2.2 Le tableau “countries” 2.3 Le tableau indicators 2.4 L’extraction des données 2.5 Exercices", " Chapitre 2 L’API Wbstats (Banque Mondiale) ## Global options library(knitr) library(dplyr) library(ggplot2) opts_chunk$set(echo=TRUE, cache=TRUE, prompt=FALSE, tidy=FALSE, comment=NA, message=FALSE, warning=FALSE) 2.1 Objectifs Supposons que l’on souhaite télécharger la population, le PIB et les émisssions de CO2 des pays du monde de 2000 à 2015. Plutôt que d’aller chercher des fichiers sur un site web, nous allons utiliser une API proposée par la Banque Mondiale qui permet de télécharger les données facilement et surtout de les mettre à jour régulièrement. Pour cela on va installer le package R correspondant à l’API wbstats de la Banque mondiale. https://cran.r-project.org/web/packages/wbstats/vignettes/Using_the_wbstats_package.html Au moment du chargement du package, il est créé un fichier wb_cachelist qui fournit l’ensemble des donnes disponibles sous la forme d’une liste de tableaux de méta-données. library(&quot;wbstats&quot;) cat&lt;-wb_cachelist str(cat,max.level = 1) List of 8 $ countries : tibble [304 × 18] (S3: tbl_df/tbl/data.frame) $ indicators : tibble [16,649 × 8] (S3: tbl_df/tbl/data.frame) $ sources : tibble [63 × 9] (S3: tbl_df/tbl/data.frame) $ topics : tibble [21 × 3] (S3: tbl_df/tbl/data.frame) $ regions : tibble [48 × 4] (S3: tbl_df/tbl/data.frame) $ income_levels: tibble [7 × 3] (S3: tbl_df/tbl/data.frame) $ lending_types: tibble [4 × 3] (S3: tbl_df/tbl/data.frame) $ languages : tibble [23 × 3] (S3: tbl_df/tbl/data.frame) 2.2 Le tableau “countries” Il fournit des renseignements de base sur les différents pays, leurs codes, etc. str(cat$countries) tibble [304 × 18] (S3: tbl_df/tbl/data.frame) $ iso3c : chr [1:304] &quot;ABW&quot; &quot;AFG&quot; &quot;AFR&quot; &quot;AGO&quot; ... $ iso2c : chr [1:304] &quot;AW&quot; &quot;AF&quot; &quot;A9&quot; &quot;AO&quot; ... $ country : chr [1:304] &quot;Aruba&quot; &quot;Afghanistan&quot; &quot;Africa&quot; &quot;Angola&quot; ... $ capital_city : chr [1:304] &quot;Oranjestad&quot; &quot;Kabul&quot; NA &quot;Luanda&quot; ... $ longitude : num [1:304] -70 69.2 NA 13.2 19.8 ... $ latitude : num [1:304] 12.52 34.52 NA -8.81 41.33 ... $ region_iso3c : chr [1:304] &quot;LCN&quot; &quot;SAS&quot; NA &quot;SSF&quot; ... $ region_iso2c : chr [1:304] &quot;ZJ&quot; &quot;8S&quot; NA &quot;ZG&quot; ... $ region : chr [1:304] &quot;Latin America &amp; Caribbean&quot; &quot;South Asia&quot; &quot;Aggregates&quot; &quot;Sub-Saharan Africa&quot; ... $ admin_region_iso3c: chr [1:304] NA &quot;SAS&quot; NA &quot;SSA&quot; ... $ admin_region_iso2c: chr [1:304] NA &quot;8S&quot; NA &quot;ZF&quot; ... $ admin_region : chr [1:304] NA &quot;South Asia&quot; NA &quot;Sub-Saharan Africa (excluding high income)&quot; ... $ income_level_iso3c: chr [1:304] &quot;HIC&quot; &quot;LIC&quot; NA &quot;LMC&quot; ... $ income_level_iso2c: chr [1:304] &quot;XD&quot; &quot;XM&quot; NA &quot;XN&quot; ... $ income_level : chr [1:304] &quot;High income&quot; &quot;Low income&quot; &quot;Aggregates&quot; &quot;Lower middle income&quot; ... $ lending_type_iso3c: chr [1:304] &quot;LNX&quot; &quot;IDX&quot; NA &quot;IBD&quot; ... $ lending_type_iso2c: chr [1:304] &quot;XX&quot; &quot;XI&quot; NA &quot;XF&quot; ... $ lending_type : chr [1:304] &quot;Not classified&quot; &quot;IDA&quot; &quot;Aggregates&quot; &quot;IBRD&quot; ... Le tableau comporte 304 observation et il mélange des pays (France), des fragments de pays (Réunion) et des agrégats de pays (Europe). Il faudra donc bien faire attention lors de l’extraction à réfléchir à ce que l’on souhaite utiliser. Par exemple, si l’on veut juste les pays : ## Programme en langage R_base # pays&lt;-cat$countries[cat$countries$income_level!=&quot;Aggregates&quot;,c(&quot;iso3c&quot;, &quot;country&quot;,&quot;capital_city&quot;,&quot;longitude&quot;,&quot;latitude&quot;, &quot;region&quot;,&quot;income_level&quot;)] ## Programme en langage dplyr pays &lt;- cat$countries %&gt;% filter(income_level !=&quot;Aggregates&quot;) %&gt;% select(iso3c,country, capital_city, latitude, longitude, region, income_level) kable(head(pays)) iso3c country capital_city latitude longitude region income_level ABW Aruba Oranjestad 12.51670 -70.0167 Latin America &amp; Caribbean High income AFG Afghanistan Kabul 34.52280 69.1761 South Asia Low income AGO Angola Luanda -8.81155 13.2420 Sub-Saharan Africa Lower middle income ALB Albania Tirane 41.33170 19.8172 Europe &amp; Central Asia Upper middle income AND Andorra Andorra la Vella 42.50750 1.5218 Europe &amp; Central Asia High income ARE United Arab Emirates Abu Dhabi 24.47640 54.3705 Middle East &amp; North Africa High income 2.3 Le tableau indicators Il comporte pas loin de 17000 variables … Autant dire qu’il est difficile de l’explorer facilement si l’on ne sait pas ce que l’on cherche. indic&lt;-cat$indicators dim(indic) [1] 16649 8 kable(head(indic)) indicator_id indicator unit indicator_desc source_org topics source_id source 1.0.HCount.1.90usd Poverty Headcount ($1.90 a day) NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2011 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.2.5usd Poverty Headcount ($2.50 a day) NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Mid10to50 Middle Class ($10-50 a day) Headcount NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Ofcl Official Moderate Poverty Rate-National NA The poverty headcount index measures the proportion of the population with daily per capita income below the official poverty line developed by each country. LAC Equity Lab tabulations of data from National Statistical Offices. 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Poor4uds Poverty Headcount ($4 a day) NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Vul4to10 Vulnerable ($4-10 a day) Headcount NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 2.3.1 Recherche du code d’un indicateur Supposons qu’on recherche les données récentes sur les émissions de CO2. On va utiliser le mot-clé CO2 pour rechercher les variables correspondantes dans le catalogue à l’aide de la fonction wbsearch, ce qui donne 45 réponses vars &lt;- wbsearch(pattern = &quot;CO2&quot;,fields=&quot;indicator&quot;) kable(vars) indicatorID indicator 5294 EN.ATM.CO2E.CP.KT CO2 emissions from cement production (thousand metric tons) 5295 EN.ATM.CO2E.EG.ZS CO2 intensity (kg per kg of oil equivalent energy use) 5296 EN.ATM.CO2E.FF.KT CO2 emissions from fossil-fuels, total (thousand metric tons) 5297 EN.ATM.CO2E.FF.ZS CO2 emissions from fossil-fuels (% of total) 5298 EN.ATM.CO2E.GDP CO2 emissions, industrial (kg per 1987 US$ of GDP) 5299 EN.ATM.CO2E.GF.KT CO2 emissions from gaseous fuel consumption (kt) 5300 EN.ATM.CO2E.GF.ZS CO2 emissions from gaseous fuel consumption (% of total) 5301 EN.ATM.CO2E.GL.KT CO2 emissions from gas flaring (thousand metric tons) 5302 EN.ATM.CO2E.KD.87.GD CO2 emissions, industrial (kg per 1987 US$ of GDP) 5303 EN.ATM.CO2E.KD.GD CO2 emissions (kg per 2010 US$ of GDP) 5304 EN.ATM.CO2E.KT CO2 emissions (kt) 5305 EN.ATM.CO2E.LF.KT CO2 emissions from liquid fuel consumption (kt) 5306 EN.ATM.CO2E.LF.ZS CO2 emissions from liquid fuel consumption (% of total) 5307 EN.ATM.CO2E.PC CO2 emissions (metric tons per capita) 5308 EN.ATM.CO2E.PP.GD CO2 emissions (kg per PPP $ of GDP) 5309 EN.ATM.CO2E.PP.GD.KD CO2 emissions (kg per 2017 PPP $ of GDP) 5310 EN.ATM.CO2E.SF.KT CO2 emissions from solid fuel consumption (kt) 5311 EN.ATM.CO2E.SF.ZS CO2 emissions from solid fuel consumption (% of total) 5312 EN.ATM.GHGO.KT.CE Other greenhouse gas emissions, HFC, PFC and SF6 (thousand metric tons of CO2 equivalent) 5314 EN.ATM.GHGT.KT.CE Total greenhouse gas emissions (kt of CO2 equivalent) 5316 EN.ATM.HFCG.KT.CE HFC gas emissions (thousand metric tons of CO2 equivalent) 5317 EN.ATM.METH.AG.KT.CE Agricultural methane emissions (thousand metric tons of CO2 equivalent) 5319 EN.ATM.METH.EG.KT.CE Methane emissions in energy sector (thousand metric tons of CO2 equivalent) 5322 EN.ATM.METH.KT.CE Methane emissions (kt of CO2 equivalent) 5323 EN.ATM.METH.PC Methane emissions (kt of CO2 equivalent per capita) 5325 EN.ATM.NOXE.AG.KT.CE Agricultural nitrous oxide emissions (thousand metric tons of CO2 equivalent) 5327 EN.ATM.NOXE.EG.KT.CE Nitrous oxide emissions in energy sector (thousand metric tons of CO2 equivalent) 5330 EN.ATM.NOXE.IN.KT.CE Industrial nitrous oxide emissions (thousand metric tons of CO2 equivalent) 5332 EN.ATM.NOXE.KT.CE Nitrous oxide emissions (thousand metric tons of CO2 equivalent) 5333 EN.ATM.NOXE.MT.CE Nitrous oxide emissions (metric tons of CO2 equivalent) 5334 EN.ATM.NOXE.PC Nitrous oxide emissions (metric tons of CO2 equivalent per capita) 5336 EN.ATM.PFCG.KT.CE PFC gas emissions (thousand metric tons of CO2 equivalent) 5343 EN.ATM.SF6G.KT.CE SF6 gas emissions (thousand metric tons of CO2 equivalent) 5348 EN.CLC.GHGR.MT.CE GHG net emissions/removals by LUCF (Mt of CO2 equivalent) 5353 EN.CO2.BLDG.MT CO2 emissions from residential buildings and commercial and public services (million metric tons) 5354 EN.CO2.BLDG.ZS CO2 emissions from residential buildings and commercial and public services (% of total fuel combustion) 5355 EN.CO2.ETOT.MT CO2 emissions from electricity and heat production, total (million metric tons) 5356 EN.CO2.ETOT.ZS CO2 emissions from electricity and heat production, total (% of total fuel combustion) 5357 EN.CO2.MANF.MT CO2 emissions from manufacturing industries and construction (million metric tons) 5358 EN.CO2.MANF.ZS CO2 emissions from manufacturing industries and construction (% of total fuel combustion) 5359 EN.CO2.OTHX.MT CO2 emissions from other sectors, excluding residential buildings and commercial and public services (million metric tons) 5360 EN.CO2.OTHX.ZS CO2 emissions from other sectors, excluding residential buildings and commercial and public services (% of total fuel combustion) 5361 EN.CO2.TRAN.MT CO2 emissions from transport (million metric tons) 5362 EN.CO2.TRAN.ZS CO2 emissions from transport (% of total fuel combustion) 8231 IN.ENV.CO2.CONC CO2 Emission (in thousand metric tons of Carbon) On va finalement trouver le code de la variable recherchée EN.ATM.CO2E.KT : émissions de CO2 en kilotonnes Les deux autres variables dont nous avons besoin ont pour code NY.GDP.MKTP.CD : PIB en parités de pouvoir d’achat SP.POP.TOTL : Population totale 2.3.2 Extraction des métadonnées Une fois que l’on pense connaître le code de nos variables, on peut extraire les métadonnés pour vérifier qu’il s’agit bien de ce que l’on cherche, quelle est la source exacte, quelle est l’unité de mesure … # Programme R-base meta&lt;-cat$indicators[cat$indicators$indicator_id %in% c(&quot;SP.POP.TOTL&quot;,&quot;NY.GDP.MKTP.CD&quot;,&quot;EN.ATM.CO2E.KT&quot;),] # Programme dplyr meta&lt;-cat$indicators %&gt;% filter(indicator_id %in% c(&quot;SP.POP.TOTL&quot;,&quot;NY.GDP.MKTP.CD&quot;,&quot;EN.ATM.CO2E.KT&quot;)) kable(meta) indicator_id indicator unit indicator_desc source_org topics source_id source EN.ATM.CO2E.KT CO2 emissions (kt) NA Carbon dioxide emissions are those stemming from the burning of fossil fuels and the manufacture of cement. They include carbon dioxide produced during consumption of solid, liquid, and gas fuels and gas flaring. Carbon Dioxide Information Analysis Center, Environmental Sciences Division, Oak Ridge National Laboratory, Tennessee, United States. 19 , 6 , Climate Change, Environment 2 World Development Indicators NY.GDP.MKTP.CD GDP (current US$) NA GDP at purchaser’s prices is the sum of gross value added by all resident producers in the economy plus any product taxes and minus any subsidies not included in the value of the products. It is calculated without making deductions for depreciation of fabricated assets or for depletion and degradation of natural resources. Data are in current U.S. dollars. Dollar figures for GDP are converted from domestic currencies using single year official exchange rates. For a few countries where the official exchange rate does not reflect the rate effectively applied to actual foreign exchange transactions, an alternative conversion factor is used. World Bank national accounts data, and OECD National Accounts data files. 3 , Economy &amp; Growth 2 World Development Indicators SP.POP.TOTL Population, total NA Total population is based on the de facto definition of population, which counts all residents regardless of legal status or citizenship. The values shown are midyear estimates. (1) United Nations Population Division. World Population Prospects: 2019 Revision. (2) Census reports and other statistical publications from national statistical offices, (3) Eurostat: Demographic Statistics, (4) United Nations Statistical Division. Population and Vital Statistics Reprot (various years), (5) U.S. Census Bureau: International Database, and (6) Secretariat of the Pacific Community: Statistics and Demography Programme. 19 , 8 , Climate Change, Health 2 World Development Indicators 2.4 L’extraction des données Elle se fait à l’aide de la fonction wb_data qui comporte de nombreuses options. 2.4.1 le paramètre indicator = Ce paramètre permet de choisir les indicateurs à collecter, ce qui suppose que l’on connaisse leur code. Par exemple, supposons que l’on veuille extraire la population et le PIB pour pouvoir calculer ensuite le PIB par habitant df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;)) dim(df) [1] 13237 6 kable(head(df,6)) iso2c iso3c country date NY.GDP.MKTP.CD SP.POP.TOTL AW ABW Aruba 1960 NA 54211 AW ABW Aruba 1961 NA 55438 AW ABW Aruba 1962 NA 56225 AW ABW Aruba 1963 NA 56695 AW ABW Aruba 1964 NA 57032 AW ABW Aruba 1965 NA 57360 commentaire : Nous obtenons un tableau très grand (&gt; 13000 lignes) qui comporte les valeurs pour toutes les dates disponibles depuis 1960 et pour tous les pays, même si les valeurs sont souvent manquantes. 2.4.2 le choix d’une période de temps 2.4.2.1 les paramètres startdate = et startdate = Ces deux paramètres permettent de choisir une plage de temps. On peut par exemple décider de ne collecter que les données relatives aux années 2014, 2015 et 2016 df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;), start_date = 2014, end_date = 2016) dim(df) [1] 651 6 kable(head(df,6)) iso2c iso3c country date NY.GDP.MKTP.CD SP.POP.TOTL AW ABW Aruba 2014 2765363128 103774 AW ABW Aruba 2015 2919553073 104341 AW ABW Aruba 2016 2965921788 104872 AF AFG Afghanistan 2014 20484885120 33370794 AF AFG Afghanistan 2015 19907111419 34413603 AF AFG Afghanistan 2016 18017749074 35383128 commentaire : Le tableau ne comporte donc plus que 651 lignes correspondant aux trois dates pour les différents pays du Monde. 2.4.2.2 Le paramètre mrv (most recent value) Lorsque l’on souhaite juste obtenir les données les plus récentes, on peut remplacer les paramètres startdate = et startdate = par le paramètre mrv = suivit d’un chiffre indiquant le nombre d’années que l’on souhaite à partir de la date la plus récente. Avec mrv=1 on récupère uniquement la dernière année disponible pour au moins l’une des variables. df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;), mrv = 1) dim(df) [1] 217 6 kable(head(df,6)) iso2c iso3c country date NY.GDP.MKTP.CD SP.POP.TOTL AW ABW Aruba 2019 NA 106314 AF AFG Afghanistan 2019 19291104008 38041754 AO AGO Angola 2019 88815697793 31825295 AL ALB Albania 2019 15279183290 2854191 AD AND Andorra 2019 3154057987 77142 AE ARE United Arab Emirates 2019 421142267938 9770529 L’inconvénient de cette méthode est que cela peut aboutir à un grand nombre de valeurs manquantes si l’une des variables recherchée n’a pas été mise à jour. Par exemple, la variable relative au CO2 n’est pas disponible après 2016 et du coup le tableau va mélanger des dates différentes. df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;,&quot;EN.ATM.CO2E.KT&quot; ), mrv =1) dim(df) [1] 434 7 kable(head(df,6)) iso2c iso3c country date EN.ATM.CO2E.KT NY.GDP.MKTP.CD SP.POP.TOTL AW ABW Aruba 2016 883.747 NA NA AW ABW Aruba 2019 NA NA 106314 AF AFG Afghanistan 2016 8672.455 NA NA AF AFG Afghanistan 2019 NA 19291104008 38041754 AO AGO Angola 2016 34693.487 NA NA AO AGO Angola 2019 NA 88815697793 31825295 Il est donc préférable de sélectioner une période plus longue mrv=5 et de faire ensuite soi-même le tri : 2.4.3 Le choix des unités géographiques Le paramètre country = permet de choisir les entités spatiales à collecter, soit sous forme de liste de codes, soit à l’aide de valeurs spéciales. Par défaut; il renvoie la liste de tous les pays, mais on peut se limiter à quelques uns seulement à l’aide de leur nom en anglais (risqué …) ou de leur code ISO3 (plus sûr) 2.4.3.1 sélection de pays df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;), start_date = 2018, end_date = 2018, country = c(&quot;USA&quot;,&quot;CHN&quot;)) df$GDP.per.capita &lt;- round(df$NY.GDP.MKTP.CD / df$SP.POP.TOTL,0) kable(head(df,6)) iso2c iso3c country date NY.GDP.MKTP.CD SP.POP.TOTL GDP.per.capita CN CHN China 2018 1.389482e+13 1392730000 9977 US USA United States 2018 2.058016e+13 326687501 62996 commentaire : Il est donc facile de travailler sur un petit nombre de pays que l’on souhaite comparer. 2.4.3.2 Opérateurs spéciaux Il existe un certain nombre de paramètres spéciaux que l’on peut utiliser à la place de la liste des pays : “countries_only” (Default) “regions_only” “admin_regions_only” “income_levels_only” “aggregates_only” “all” df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;), start_date = 2018, end_date = 2018, country = &quot;regions_only&quot;) df$GDP.per.capita &lt;- round(df$NY.GDP.MKTP.CD / df$SP.POP.TOTL,0) kable(df) iso2c iso3c country date NY.GDP.MKTP.CD SP.POP.TOTL GDP.per.capita Z4 EAS East Asia &amp; Pacific 2018 2.635135e+13 2328138066 11319 Z7 ECS Europe &amp; Central Asia 2018 2.314567e+13 917922618 25215 ZJ LCN Latin America &amp; Caribbean 2018 5.823558e+12 640467174 9093 ZQ MEA Middle East &amp; North Africa 2018 3.566141e+12 448912962 7944 XU NAC North America 2018 2.230365e+13 363809186 61306 8S SAS South Asia 2018 3.445472e+12 1814388744 1899 ZG SSF Sub-Saharan Africa 2018 1.721156e+12 1078306520 1596 commentaire : Nous avons extrait les données par grandes régions du Monde pour l’année 2016 2.4.4 Le format de sortie du tableau Il existe deux façons d’extraire un tableau comprenant plusieurs variables ou plusieurs dates, selon que l’on veut un tableau large (wide) ou étroit. On peut régler la sortie à l’aide du paramètre return_wide qui est TRUE par défaut mais que l’on peut régler sur FALSE. 2.4.4.1 return_wide = FALSE df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;), return_wide = TRUE, start_date = 2016, end_date = 2018, country = c(&quot;USA&quot;,&quot;CHN&quot;)) df # A tibble: 6 x 6 iso2c iso3c country date NY.GDP.MKTP.CD SP.POP.TOTL &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 CN CHN China 2016 1.12e13 1378665000 2 CN CHN China 2017 1.23e13 1386395000 3 CN CHN China 2018 1.39e13 1392730000 4 US USA United States 2016 1.87e13 322941311 5 US USA United States 2017 1.95e13 324985539 6 US USA United States 2018 2.06e13 326687501 2.4.4.2 return_wide = FALSE df &lt;- wb_data(indicator = c(&quot;NY.GDP.MKTP.CD&quot;,&quot;SP.POP.TOTL&quot;), return_wide = FALSE, start_date = 2016, end_date = 2018, country = c(&quot;USA&quot;,&quot;CHN&quot;)) df[,1:7] # A tibble: 12 x 7 indicator_id indicator iso2c iso3c country date value &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 NY.GDP.MKTP.CD GDP (current US$) CN CHN China 2018 1.39e13 2 NY.GDP.MKTP.CD GDP (current US$) CN CHN China 2017 1.23e13 3 NY.GDP.MKTP.CD GDP (current US$) CN CHN China 2016 1.12e13 4 NY.GDP.MKTP.CD GDP (current US$) US USA United States 2018 2.06e13 5 NY.GDP.MKTP.CD GDP (current US$) US USA United States 2017 1.95e13 6 NY.GDP.MKTP.CD GDP (current US$) US USA United States 2016 1.87e13 7 SP.POP.TOTL Population, total CN CHN China 2018 1.39e 9 8 SP.POP.TOTL Population, total CN CHN China 2017 1.39e 9 9 SP.POP.TOTL Population, total CN CHN China 2016 1.38e 9 10 SP.POP.TOTL Population, total US USA United States 2018 3.27e 8 11 SP.POP.TOTL Population, total US USA United States 2017 3.25e 8 12 SP.POP.TOTL Population, total US USA United States 2016 3.23e 8 2.5 Exercices 2.5.1 Exercice 1 Extraire les métadonnées relatives à la variable SP.URB.TOTL indicator_id indicator unit indicator_desc source_org topics source_id source SP.URB.TOTL Urban population NA Urban population refers to people living in urban areas as defined by national statistical offices. It is calculated using World Bank population estimates and urban ratios from the United Nations World Urbanization Prospects. Aggregation of urban and rural population may not add up to total population because of different country coverages. World Bank staff estimates based on the United Nations Population Division’s World Urbanization Prospects: 2018 Revision. 19 , 16 , Climate Change , Urban Development 2 World Development Indicators meta&lt;-cat$indicators[cat$indicators$indicator_id %in% c(&quot;SP.URB.TOTL&quot;),] 2.5.2 Exercice 2 Créer un tableau de la population des pays du monde en 2000, triez le par ordre décroissant et affichez les 10 pays les plus peuplés avec leur nom,leur code et la population en millions Code Pays Population CHN China 1262.6 IND India 1056.6 USA United States 282.2 IDN Indonesia 211.5 BRA Brazil 174.8 RUS Russian Federation 146.6 PAK Pakistan 142.3 BGD Bangladesh 127.7 JPN Japan 126.8 NGA Nigeria 122.3 # Chargement des données avec l&#39;API tab &lt;- wb_data(indicator = c(&quot;SP.POP.TOTL&quot;), start_date=2000, end_date = 2000) ### Tri, sélection, transformation et recodage en R-Base # tab&lt;-tab[order(tab$SP.POP.TOTL,decreasing = T),] # tab&lt;-tab[,c(&quot;iso3c&quot;,&quot;country&quot;,&quot;SP.POP.TOTL&quot;)] # tab$SP.POP.TOTL&lt;-tab$SP.POP.TOTL/1000000 # names(tab)&lt;-c(&quot;Code&quot;, &quot;Nom&quot;, &quot;Population&quot;) ### Tri, sélection, transformationet recodage en dplyr tab&lt;- tab %&gt;% arrange(desc(SP.POP.TOTL)) %&gt;% select(iso3c, country, SP.POP.TOTL) %&gt;% mutate(SP.POP.TOTL = SP.POP.TOTL/1000000) %&gt;% rename(Code=iso3c, Pays = country, Population = SP.POP.TOTL) # Affichage du résultat kable(head(tab,10), digits=1) 2.5.3 Exercice 3 On se propose de comparer l’évolution des émissions de CO2 (EN.ATM.CO2E.KT)de la Chine (CHN), l’Inde (IND), la Russie (RUS) le Japon (JPN) et des Etats-Unis d’Amérique (USA) de 1995 à 2015. 2.5.3.1 CO2 en valeur brute (tonnes) Réalisez un graphique présentant les valeurs de CO2 en milliers de tonnes avec une échelle logarithmique sur l’axe y pour mieux visualiser les taux de croissance. # Chargement des données avec l&#39;API tab &lt;- wb_data(indicator = c(&quot;EN.ATM.CO2E.KT&quot;), country = c(&quot;CHN&quot;,&quot;IND&quot;,&quot;RUS&quot;,&quot;USA&quot;,&quot;JPN&quot;), start_date=1995, end_date = 2015) p&lt;-ggplot(tab) + aes(x=date, y = EN.ATM.CO2E.KT, color= country) + geom_line() + scale_y_log10(&quot;en milliers de t&quot;) + ggtitle(label = &quot;Principaux pays émetteurs de CO2 (1995-2015)&quot;, subtitle = &quot;Source : Banque Mondiale - API wbstat&quot;) p 2.5.3.2 CO2 en valeur relative (tonnes par habitant) Même exercice mais en téléchargeant aussi la population (SP.POP.TOTL) de façon à calculer la variable CO2.per.capita qui mesure le nombre de tonnes de CO2 par habitant. On utilisera cette fois-ci une échelle arithmétique sur l’axe vertical. # Chargement des données avec l&#39;API tab &lt;- wb_data(indicator = c(&quot;EN.ATM.CO2E.KT&quot;, &quot;SP.POP.TOTL&quot;), country = c(&quot;CHN&quot;,&quot;IND&quot;,&quot;RUS&quot;,&quot;USA&quot;,&quot;JPN&quot;), start_date=1995, end_date = 2015) tab &lt;- tab %&gt;% mutate(CO2.per.capita = 1000*EN.ATM.CO2E.KT/SP.POP.TOTL) # Visualisation avec ggplot2 p&lt;-ggplot(tab) + aes(x=date, y = CO2.per.capita, color= country) + geom_line() + scale_y_continuous(&quot;en tonnes par habitant&quot;) + ggtitle(label = &quot;Principaux pays émetteurs de CO2 (1995-2015)&quot;, subtitle = &quot;Source : Banque Mondiale - API wbstat&quot;) p 2.5.4 Exercice 4 On se propose de comparer les plus grands pays du Monde en combinant deux critères : DEVDUR = Développement durable : mesuré par les quantités de CO2 par habitant DEVECO = Développement économique : mesurée par le PIB par habitant 2.5.4.1 Analyse pour une année (2010) et un seuil de population (10 millions) On construit un programme pour une année précise (2010)et en ne retenant que les pays ayant une population minimale (10 millions d’habitants) # Chargement des données avec l&#39;API tab &lt;- wb_data(indicator = c(&quot;EN.ATM.CO2E.KT&quot;, &quot;SP.POP.TOTL&quot;,&quot;NY.GDP.MKTP.CD&quot;), start_date=2010, end_date = 2010) tab &lt;- tab %&gt;% mutate(DEVDUR = 1000*EN.ATM.CO2E.KT/SP.POP.TOTL, DEVECO = NY.GDP.MKTP.CD/SP.POP.TOTL, POP = SP.POP.TOTL/1000000) %&gt;% rename(Code = iso3c, Pays = country) %&gt;% select(Code,Pays, POP, DEVDUR, DEVECO)%&gt;% filter(POP &gt; 10) # Visualisation avec ggplot2 p&lt;-ggplot(tab) + aes(x=DEVECO, y = DEVDUR) + geom_point(aes(size=POP),col=&quot;red&quot;) + geom_text(aes(label=Code), size=2, nudge_y=1)+ scale_x_log10(&quot;PIB par habitant (échelle logarithmique)&quot;) + scale_y_continuous(&quot;CO2 par habitant&quot;) + ggtitle(label = &quot;Développement dans le Monde en 2010&quot;, subtitle = &quot;Source : Banque Mondiale - API wbstat&quot;) p 2.5.4.2 Création d’une fonction f(année, population) On reprend le même programme mais sous forme d’une fonction mongraphique() renvoyant le diagramme en selon le choix de deux paramètres : l’année et le seuil minimal de population. On teste ensuite la fonction pour l’année 1996 et l’année 2016 en prenant un seuil de 50 millions d’habitants. mongraphique &lt;-function(year = 2010, minpop = 10) { # Chargement des données avec l&#39;API tab &lt;- wb_data(indicator = c(&quot;EN.ATM.CO2E.KT&quot;, &quot;SP.POP.TOTL&quot;,&quot;NY.GDP.MKTP.CD&quot;), start_date=year, end_date = year) tab &lt;- tab %&gt;% mutate(DEVDUR = 1000*EN.ATM.CO2E.KT/SP.POP.TOTL, DEVECO = NY.GDP.MKTP.CD/SP.POP.TOTL, POP = SP.POP.TOTL/1000000) %&gt;% rename(Code = iso3c, Pays = country) %&gt;% select(Code,Pays, POP, DEVDUR, DEVECO)%&gt;% filter(POP &gt; minpop) # Visualisation avec ggplot2 p&lt;-ggplot(tab) + aes(x=DEVECO, y = DEVDUR) + geom_point(aes(size=POP),col=&quot;red&quot;) + geom_text(aes(label=Code), size=2, nudge_y=1)+ scale_x_log10(&quot;PIB par habitant (échelle logarithmique)&quot;) + scale_y_continuous(&quot;CO2 par habitant&quot;) + ggtitle(label = paste(&quot;Développement dans le Monde en &quot;, year), subtitle = &quot;Source : Banque Mondiale - API wbstat&quot;) p } mongraphique(1996,50) mongraphique(2016,50) "],["03-API-worldmap.html", "Chapitre 3 L’API Natural Earth 3.1 Objectifs 3.2 Exemple de combinaison des API wbstats et naturalearth", " Chapitre 3 L’API Natural Earth ## Global options library(knitr) library(dplyr) library(sf) opts_chunk$set(echo=TRUE, cache=TRUE, prompt=FALSE, tidy=FALSE, comment=NA, message=FALSE, warning=FALSE) 3.1 Objectifs Nous allons ici utiliser le fonds de carte Natural Earth qui est un fonds de carte libre de droit et mis à jour régulièrement. Le site web du projet se situe à l’adresse suivante : https://www.naturalearthdata.com/ Il indique ses objectifs comme suit : “Natural Earth is a public domain map dataset available at 1:10m, 1:50m, and 1:110 million scales. Featuring tightly integrated vector and raster data, with Natural Earth you can make a variety of visually pleasing, well-crafted maps with cartography or GIS software.[…] Natural Earth was built through a collaboration of many volunteers and is supported by NACIS (North American Cartographic Information Society), and is free for use in any type of project (see our Terms of Use page for more information).” On peut télécharger les différents fonds de carte sur le site web, mais dans une perspective de mise à jour automatique régulière du fonds de carte il est plus pertinent d’utiliser l’API rnaturalearthqui permet d’accéder directement à la plupart des fonds de carte avec juste quelques lignes de code. Il suffit pour cela de commencer par installer et charger le package. library(&quot;rnaturalearth&quot;) library(&quot;rnaturalearthdata&quot;) 3.1.1 Quel fonds de carte choisir ? 3.1.2 le fonds de carte countries110 (175 unités) On va télécharger tout d’abord le fonds de carte des pays du Monde avec une forte généralisation des contours countries110 et le transformer en objet de type spatial feature du package sf du package avant de le visualiser et d’ examiner le nombre d’unités map&lt;-st_as_sf(countries110) par(mar=c(0,0,0,0), mfrow=c(1,1)) plot(map$geometry,col=&quot;lightyellow&quot;) dim(map) [1] 177 64 Ce fonds de carte comporte 175 unités spatiales, mais de quoi s’agit-il exactement. Les métadonnées associées permettent de se faire une idée plus précise de la nature exacte de ces unités. Prenons pour cela quelques exempes sel&lt;-map[map$adm0_a3 %in% c(&quot;FRA&quot;, &quot;NCL&quot;,&quot;ATA&quot;,&quot;ATF&quot;,&quot;USA&quot;, &quot;PRI&quot;,&quot;CHN&quot;,&quot;TWN&quot;,&quot;MAR&quot;, &quot;SAH&quot;,&quot;CHN&quot;,&quot;TWN&quot;,&quot;ISR&quot;,&quot;PSX&quot;),c(&quot;sovereignt&quot;,&quot;sov_a3&quot;,&quot;type&quot;,&quot;admin&quot;, &quot;adm0_a3&quot;,&quot;name&quot;,&quot;note_adm0&quot;,&quot;iso_a3&quot;,&quot;wb_a3&quot;)] kable(sel) sovereignt sov_a3 type admin adm0_a3 name note_adm0 iso_a3 wb_a3 geometry 6 Antarctica ATA Indeterminate Antarctica ATA Antarctica NA ATA NA MULTIPOLYGON (((-59.57209 -… 7 France FR1 Dependency French Southern and Antarctic Lands ATF Fr. S. Antarctic Lands Fr. ATF NA MULTIPOLYGON (((68.935 -48…. 30 China CH1 Country China CHN China NA CHN CHN MULTIPOLYGON (((110.3392 18… 55 France FR1 Country France FRA France NA FRA FRA MULTIPOLYGON (((-52.55642 2… 78 Israel ISR Sovereign country Israel ISR Israel NA ISR ISR MULTIPOLYGON (((35.71992 32… 99 Morocco MAR Sovereign country Morocco MAR Morocco NA MAR MAR MULTIPOLYGON (((-5.193863 3… 113 France FR1 Dependency New Caledonia NCL New Caledonia Fr. NCL NCL MULTIPOLYGON (((165.78 -21…. 128 United States of America US1 Dependency Puerto Rico PRI Puerto Rico Commonwealth of U.S.A. PRI PRI MULTIPOLYGON (((-66.28243 1… 132 Israel ISR Disputed Palestine PSX Palestine Partial self-admin. PSE WBG MULTIPOLYGON (((35.54567 32… 137 Western Sahara SAH Indeterminate Western Sahara SAH W. Sahara Self admin. ESH NA MULTIPOLYGON (((-8.794884 2… 163 Taiwan TWN Sovereign country Taiwan TWN Taiwan NA TWN NA MULTIPOLYGON (((121.7778 24… 168 United States of America US1 Country United States of America USA United States NA USA USA MULTIPOLYGON (((-155.5421 1… Les exemples présentés dans le tableau ci-dessus montrent la complexité du problème de définition et de représentation cartographique des “pays” ou “bouts du monde”. Quelques remarques : La France (FR1) en tant qu’état souverain regroupe ici cartographiquement la partie métropolitaine du pays et les Départements d’Outre-Mer (Guyane Française, Réunion, Martinique, Guadeloupe) en une seule entité spatiale, mais elle met à part la Nouvelle Calédonie et les îles antarctiques. Porto Rico (PRI) est considéré comme une dépendance des Etats-Unis (US1) au même titre que la Nouvelle Calédonie(NCL) est considérée comme une dépendance de la France (FR1). Le Sahara occidental (SAH) est considéré comme une zone indéterminée bien qu’il soit occupé par le Maroc (MAR). la Palestine (PSX) est considéré comme une zone disputée mais rattachée en terme de souveraineté à Israël (ISR) et une note précise qu’elle est partiellement semi-administrée. Le code sur trois caractères des territoires palestiniens est très variable selon les organisations (PSX, PSE, WBG). Taïwan (TWN) est présenté comme un état souverain, mais son code ISO3 est manquant pour la banque mondiale car la Chine refuse de le reconnaître. Plusieurs états souverains de petite taille sont absents de ce fonds de carte qui ne regroupe que 175 unités soit moins que les 193 pays membres des Nations-Unies. La plupart des îles du Pacifique sont en particulier éliminées car leur surface les rendrait invisible pour le degré de généralisation cartographique adopté. 3.1.3 le fonds de carte sovereignty110 (171 unités) On peut obtenir un fonds différent en installant le package complémentaire rnaturalearthdata qui permet notamment de distinguer le fonds de carte des countries (c’est-à-dire des “bouts du monde” souverains ou non) et des sovereignty (c’est-à-dire des états souverains) library(rnaturalearthdata) map&lt;-st_as_sf(sovereignty110) par(mar=c(0,0,0,0)) plot(map$geometry,col=&quot;lightyellow&quot;) dim(map) [1] 171 64 Le fonds de carte permet désormais de récupérer la plupart des pays souverains du Monde, y compris les petits états insulaires du Pacifique, mais il fait disparaître de façon sélective les territoires indéterminés ou disputés. Ainsi, le Sahra Occidental demeure partiellement séparé du Maroc mais les territoires palestiniens sont annexés à Israël ainsi que le plateau du Golan ce qui n’est évidemment pas un choix neutred’un point de vue géoolitique. par(mfrow=c(1,2)) plot(map[map$sov_a3 %in% c(&quot;ISR&quot;,&quot;JOR&quot;,&quot;SYR&quot;,&quot;LBN&quot;,&quot;EGY&quot;),]$geometry, col=c(&quot;gray80&quot;,&quot;orange&quot;,&quot;gray80&quot;,&quot;gray80&quot;,&quot;gray80&quot;)) title(&quot;Limits of Israël&quot;,cex=0.5) plot(map[map$sov_a3 %in% c(&quot;MAR&quot;,&quot;SAH&quot;,&quot;DZA&quot;,&quot;MRT&quot;),]$geometry, col=c(&quot;gray70&quot;,&quot;orange&quot;,&quot;gray70&quot;,&quot;lightyellow&quot;)) title(&quot;Limits of Morocco&quot;) 3.1.4 Le fonds de carte tinycountries110 On peut aussi revenir au fonds de carte des countries et extraire les “petits pays” en ne conservant que leur point central, sans tracer un polygône de contour. On pourra ainsi les cartographier sous forme ponctuelle. map&lt;-st_as_sf(countries110) small&lt;-st_as_sf(tiny_countries110) par(mar=c(0,0,0,0), mfrow=c(1,1)) plot(map$geometry,col=&quot;lightyellow&quot;) plot(small$geometry,col=&quot;red&quot;, add=T) 3.1.5 Le fonds de carte countries50 On peut également choisir un fonds moins généralisé dans leque tous les petits pays seront présents map&lt;-st_as_sf(countries50) par(mar=c(0,0,0,0)) plot(map$geometry,col=&quot;lightyellow&quot;) 3.1.6 Autres fonds de carte : Il existe toute une série d’autres fonds de carte dans le package Natural Earth, notamment avec des résolutions plus précises, mais on se limitera ici à l’exploration des fonds de carte utile pour produire des cartes à contour généralisé couvrant le monde entier. 3.2 Exemple de combinaison des API wbstats et naturalearth Nous allons finalement essayer de constituer une carte des émissions de CO2 en 2016 basée sur la combinaison des données wbstats et du fonds de carte naturalearth. 3.2.1 Etape 1 : récupération des données statistiques library(wbstats) cat&lt;-wb_cachelist don1&lt;-cat$countries %&gt;% filter(region !=&quot;Aggregates&quot;) %&gt;% select(iso3c,country, longitude, latitude) don2 &lt;- wb_data(indicator = c(&quot;EN.ATM.CO2E.KT&quot;), start_date=2015, end_date = 2015) %&gt;% select(iso3c, EN.ATM.CO2E.KT) don &lt;- left_join(don1,don2) %&gt;% rename(ISO3 = iso3c, CO2 = EN.ATM.CO2E.KT) kable(head(don)) ISO3 country longitude latitude CO2 ABW Aruba -70.0167 12.51670 898.415 AFG Afghanistan 69.1761 34.52280 9035.488 AGO Angola 13.2420 -8.81155 34583.477 ALB Albania 19.8172 41.33170 4616.753 AND Andorra 1.5218 42.50750 465.709 ARE United Arab Emirates 54.3705 24.47640 194765.371 3.2.2 Etape 2 : Récupération du fonds de carte map&lt;-st_as_sf(sovereignty110) map&lt;-st_as_sf(sovereignty110) %&gt;% select(adm0_a3,geometry) %&gt;% rename(ISO3 = adm0_a3) head(map) # A tibble: 6 x 2 ISO3 geometry &lt;chr&gt; &lt;MULTIPOLYGON [°]&gt; 1 AFG (((61.21082 35.65007, 62.23065 35.27066, 62.98466 35.40404, 63.19354 35… 2 AGO (((16.32653 -5.87747, 16.57318 -6.622645, 16.86019 -7.222298, 17.09 -7.… 3 ALB (((20.59025 41.8554, 20.46318 41.51509, 20.60518 41.08623, 21.02004 40.… 4 ARE (((51.57952 24.2455, 51.75744 24.29407, 51.79439 24.01983, 52.57708 24.… 5 ARG (((-65.5 -55.2, -66.45 -55.25, -66.95992 -54.89681, -67.56244 -54.87001… 6 ARM (((43.58275 41.09214, 44.97248 41.24813, 45.1795 40.98535, 45.56035 40.… 3.2.3 Etape 3 : Jointure du fonds de carte et des statistiques mapdon &lt;- inner_join(don,map) 3.2.4 Etape 4 :Visualisation avec plotly # Create map library(plotly) g &lt;- list(showframe = TRUE, framecolor= toRGB(&quot;gray50&quot;), coastlinecolor = toRGB(&quot;black&quot;), showland = TRUE, landcolor = toRGB(&quot;lightyellow&quot;), showcountries = TRUE, countrycolor = toRGB(&quot;black&quot;), countrywidth = 0.2, # projection = list(type = &#39;azimuthal equal area&#39;)) projection = list(type = &#39;Mercator&#39;)) p&lt;- plot_geo(mapdon)%&gt;% add_markers(x = ~longitude, y = ~latitude, sizes = c(0, 1000), size = ~CO2, color= &quot;red&quot;, hoverinfo = &quot;text&quot;, text = ~paste(&#39;Pays: &#39;, country, &#39;&lt;br /&gt; CO2 en kT : &#39;,CO2)) %&gt;% layout(geo = g, title = &quot;Emissions de CO2 en 2015&quot;, width=800, height = 400) p "]]
